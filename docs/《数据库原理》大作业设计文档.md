# 《数据库原理》大作业设计文档

**常珂华 2019010798 刘臣洋 2019011250  杨健辉 2019011248 张博闻 2019013267 **

## 一、完成情况

小组按照《大作业说明》完成了所有基础要求，并实现了两个进阶项：where条件支持逻辑运算符（and/or），多事务并发的恢复。

## 二、实现方法

### 1. 查询模块

#### **CREATE TABLE**

在`ImpVisitor`中，根据生成的语法分析树设置列属性和约束。其中，约束需要分别处理紧接在属性定义之后的约束和在语句末尾用`Primary Key(AttrName)`定义的约束。

该语句要求且只能指定一个属性作为主键。主键属性将被设置为`not null`。之后，调用当前`Database`创建数据表。

#### **DROP TABLE**

获取当前表的互斥锁，再删除表`Database.drop()`以删除数据表。

#### **SHOW TABLE**

通过表名访问该表，根据指定格式输出该表的名称、各属性的名称和类别。

#### **INSERT INTO**

分有无声明属性列处理。

对未声明属性列的情况，检查输入数据个数与表属性数是否相等。若相等，则插入数据表。若违反一致性，则报错。

对声明属性列的情况，检查三个指标：输入数据个数与声明属性数是否相同，声明属性是否包括主键，声明属性是否均为表中属性。若通过检查，则插入数据表。若违反一致性，则报错。

#### **UPDATE**

首先获取目标行的集合S。若语句不包含`where`，则S为所有行的集合。若语句包含`where`，则根据比较式筛选数据，得到S。

具体的筛选方法是：每次使用一个比较式筛选，依次检查所有行，运算结果根据逻辑连接词取交或并集。

然后将S的每一行执行更新操作。若违反一致性，则报错。

#### **DELETE**

首先获取目标行的集合S。若语句不包含`where`，则S为所有行的集合。若语句包含`where`，则根据比较式筛选数据，得到S。筛选方式与UPDATE的方法一致。

然后删除S里的每一行。

#### **SELECT**

选择语句处理流程为：构建查询工具表，进行条件筛选，进行投影。

首先依据代码框架中所给出工具类`QueryResult`完善其构造函数。由于`select`最终返回列的名称与所对应的元组，因此将`Columns`和`ArrayList<Row>`作为其构造函数的参数。代码框架中`QueryTable`类为查询时的临时数据表，因此需要保存列的属性以及行的元组数据，将其作为类属性添加。`SELECT`语句中构建Table为核心工作，涉及到取笛卡尔积等操作，因此其构造函数需要重载，分别对应一张表为参数的情况和两张表及连接条件为参数的情况。

从一张表中选择时，以该表为参数构建工具表；从笛卡尔积中选择时，先分别根据两表构建工具表，而后依据两工具表生成结果工具表；自然连接时与笛卡尔积操作相同，但需要去除重复名称的属性，若没有重复属性则需退化为笛卡尔积。

筛选时通过框架中的`Cell`类实现的`compareTo`方法实现，获得比较符后判断比较条件而后从迭代器中选择满足条件的元组加入新工具表。

投影时获取需要的属性的`index`并且从元组中选择对应`index`的数据加入新工具表。

### 2.事务并发与恢复模块

#### **BEGIN TRANSACTION与COMMIT**

维护一个队列`currentSessions`，用于记录处于事务状态的`Session`。对于非事务状态`Session`的语句S，将之转化为`Begin Transaction; S; Commit;`的语句序列再执行。对于事务状态`Session`的语句S，直接执行即可。此外，还需要在执行语句前记录下日志。

#### **实现read committed隔离级别**

采用读写锁机制：读锁之间相容，可以被多个对象获取；写锁与写锁、读锁互斥，只能被一个对象获取；未获取到目标锁时，进程阻塞一段时间。对每一个`Table`对象，维护两个数组：` sLockSessions`和` xLockSessions`，用以记录当前获取锁的`Session`。从而实现读写锁机制。

当执行**DROP TABLE, UPDATE, INSERT INTO, DELETE**指令时，需要在修改数据前获取写锁。当执行**SELECT**指令时，需要在读取数据前获取读锁。当事务获取写锁后，只能在执行**COMMIT**指令时释放写锁，从而实现**read committed**隔离级别。

#### **实现事务的WAL机制**

实现了`writeLog`和`readLog`两个方法：

每当一个`Session`执行一条`Statement`时，我们调用`writeLog`将这条`Statement`与`Session`的编号一同写入到对应数据库的日志文件中；

每次重启`server`，我们调用`readLog`方法，分别处理上次`server`运行过程中每一个`Session`的操作，具体方法是查找每个`Session`的最后一次`commit`，并忽略它在此后的所有操作，然后按时间顺序处理所有`Statement`即可。

由于多个`Session`可能同时写入同一个日志文件，需要给每个数据库开设专门的读写锁`ReentrantReadWriteLock`。

## 三、小组分工

**常珂华** WAL机制的设计与实现

**刘臣洋** `Select`语句笛卡尔积、自然连接表构建，筛选，投影

**杨健辉** `Delete,Insert`语句实现，read commited隔离级别设计与实现

**张博闻** `Update`语句设计与实现

**共同完成** `Create Table`语句设计与实现，文档撰写
